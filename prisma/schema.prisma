// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// PostgreSQL supporte les enums, mais on utilise des strings pour la compatibilité
// ProgressStatus: "not_seen" | "learning" | "to_review" | "mastered"
// DifficultyTag: "easy" | "medium" | "hard"

model Question {
  id            String   @id
  questionnaire Int
  question      String
  categorie     String?
  astag         String?  @map("astag D/F/I ")
  enonce        String?
  optionA       String?
  optionB       String?
  optionC       String?
  optionD       String?
  bonneReponse  String
  imagePath     String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  attempts      Attempt[]
  progresses    QuestionProgress[]
  userProgress  UserProgress[]
  examAnswers   ExamAnswer[]
}

model Attempt {
  id         String   @id @default(cuid())
  userId     String?
  questionId String
  choix      String
  correct    Boolean
  timeSpent  Int?     // Temps en secondes pour cette tentative
  createdAt  DateTime @default(now())
  question   Question @relation(fields: [questionId], references: [id])
  user       User?    @relation(fields: [userId], references: [id])
}

model ExamHistory {
  id                String   @id @default(cuid())
  userId            String
  score             Int
  percentage        Float
  total             Int
  correct           Int
  incorrect         Int
  timeSpent         Int      // Temps en secondes
  completedAt       DateTime @default(now())
  
  // Nouveaux champs de performance
  performanceScore  Int?
  accuracyScore     Int?
  speedBonus        Int?
  avgTimePerQuestion Int?
  performanceBadge  String?  // 'gold', 'silver', 'bronze', 'standard'
  
  // Relation avec User
  user              User     @relation(fields: [userId], references: [id])
  answers           ExamAnswer[]  // Réponses détaillées de l'examen
  
  @@index([userId])
}

model ExamAnswer {
  id            String      @id @default(cuid())
  examHistoryId String
  questionId    String
  choix         String
  correct       Boolean
  createdAt     DateTime    @default(now())
  
  examHistory   ExamHistory @relation(fields: [examHistoryId], references: [id], onDelete: Cascade)
  question      Question    @relation(fields: [questionId], references: [id])
  
  @@index([examHistoryId])
  @@index([questionId])
}

model QuestionProgress {
  id                 String          @id @default(cuid())
  userId             String?
  questionId         String
  repetitions        Int             @default(0)
  consecutiveCorrect Int             @default(0)
  accuracy           Float           @default(0)
  easiness           Float           @default(2.5)
  intervalDays       Int             @default(0)
  nextDueAt          DateTime?
  lastAttemptAt      DateTime?
  status             String          @default("not_seen")
  difficultyTag      String?

  question           Question        @relation(fields: [questionId], references: [id])
  user               User?           @relation(fields: [userId], references: [id])

  @@index([userId, questionId])
}

// Modèles d'authentification NextAuth
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String?   // Pour Credentials provider
  role          String    @default("STUDENT") // ADMIN ou STUDENT
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  attempts      Attempt[]
  progresses    QuestionProgress[]
  userProgress  UserProgress[]
  achievements  Achievement[]
  examHistory   ExamHistory[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Modèle pour sauvegarder la progression utilisateur
model UserProgress {
  id                    String   @id @default(cuid())
  userId                String
  questionId            String
  attempts              Int      @default(0)
  lastAttemptCorrect    Boolean?
  lastAttemptAt         DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question              Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId])
}

// Modèle pour les trophées et succès
model Achievement {
  id          String   @id @default(cuid())
  userId      String
  type        String   // "exam_perfect", "streak", "answers_streak", "category_master", etc.
  level       String   // "bronze", "silver", "gold"
  unlockedAt  DateTime @default(now())
  value       Int      // Valeur associée (ex: 5 pour "5 en suite")
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, type, level])
  @@index([userId])
}
